import colorsRaw from 'material-colors'
import { mkdirSync, writeFileSync } from 'node:fs'
import { runScript } from './utils/script-helper'
import { toShortHex } from './utils/css-helper'
import { dirname, join } from 'node:path'
import { toPascalCase } from '../src/utils/stringManipulation'
import { isAccessible } from '../src/utils/wcag'
import { shouldSkipGeneration, updateCache } from './utils/cache-helper'

const SCRIPT_NAME = 'generate-colors'
const SOURCE_FILES = ['scripts/generate-colors.ts', 'node_modules/material-colors/dist/colors.json']
const OUTPUT_FILES = [
	'src/assets/typescript/colors.ts',
	'src/assets/styles/colors.css',
	'docs/colors.md',
	'src/components/00-foundations/colors.mdx',
]

// Check if we can skip generation
if (shouldSkipGeneration(SCRIPT_NAME, SOURCE_FILES, OUTPUT_FILES)) {
	process.exit(0)
}

const specialColors: ColorName[] = ['white', 'black']

/**
 * Generate TS file
 */

const flatColors: Record<string, string> = {}

Object.entries(colorsRaw).forEach(([colorName, shades]) => {
	if (typeof shades === 'object') {
		Object.entries(shades as object).forEach(([shade, value]) => {
			// Only use numeric shades, skip non-numeric (like "A100") if you want or keep all keys
			if (!Number.isNaN(Number(shade))) {
				const key = `${colorName}-${shade}`
				flatColors[key] = value as string
			}
		})
	} else if (typeof shades === 'string') {
		flatColors[colorName] = shades
	}
})

const colorNames: string[] = Object.keys(flatColors)
	.map((color) => color.split('-')[0])
	.reduce((result: string[], current) => {
		if (!result.includes(current)) {
			result.push(current)
		}
		return result
	}, [])

// Generate color family names (without shade numbers) - excluding special colors
const colorFamilies = colorNames.filter((name) => !specialColors.includes(name))

const tsContent = `/**
 * --------------------------------------------------------------------
 * THIS FILE IS AUTO-GENERATED — DO NOT EDIT IT DIRECTLY!
 *
 * This file was generated by the generate-colors script.
 * Any manual changes will be overwritten.
 * --------------------------------------------------------------------
 */

/**
 * array for all possible colors names (including special colors)
*/
export const colorNames = \n${JSON.stringify(colorNames, null, 2)} as const

/**
 * array for color families (without shade numbers)
 * Users specify these, and CSS handles the specific shade (500 by default)
*/
export const colors = \n${JSON.stringify(colorFamilies, null, 2)} as const

/**
 * type that define all colors available for components
 * Only color families are exposed (e.g., "blue", "green", not "blue500")
*/
export type Color = typeof colors[number]

/**
 * object of all possible color values with shades
 * Internal use only - for CSS generation
*/
export const colorsFlat = ${JSON.stringify(flatColors, null, 2)}
`

writeFileSync('src/assets/typescript/colors.ts', tsContent)

console.log('✅ colors.ts generated')

runScript('npx prettier --write src/assets/typescript/colors.ts')

/**
 * Generate CSS file
 */

// CSS colors
const cssVarsArr: string[] = []

Object.entries(flatColors).forEach(([colorName, value]) => {
	cssVarsArr.push(`\t--neo-color-${colorName.replace('-', '')}: ${toShortHex(value)};`)
})

const cssVars = cssVarsArr.join('\n')

// Generate themed CSS classes for color families only (not individual shades)
// Strategy: Each color family gets ONE CSS class (e.g., .Themed--blue)
// The class automatically uses shade 500 as main color, shade 200 as accent
const themedClasses: string[] = []
const processedFamilies = new Set<string>()

Object.entries(flatColors).forEach(([colorName, value]) => {
	const [family, shade] = colorName.split('-')

	// Only process shade 500 for regular colors (or no shade for special colors like white/black)
	if (shade !== '500' && shade !== undefined) {
		return
	}

	// Skip if we've already processed this family
	if (processedFamilies.has(family)) {
		return
	}
	processedFamilies.add(family)

	// Calculate text color based on the 500 shade (WCAG accessible)
	const bg = toShortHex(value)
	let textColor = 'white'
	if (isAccessible(bg, '#ffffff')) {
		textColor = 'white'
	} else if (isAccessible(bg, '#000000')) {
		textColor = 'black'
	}

	// Determine the accent shade (200) for this color family
	const accentShade = '200'
	const accentColorKey = `${family}-${accentShade}`
	const hasAccent = flatColors[accentColorKey] !== undefined

	// Generate class using just the family name (no shade number)
	const className = family // e.g., "blue" not "blue500"
	const mainColorVar = shade ? `${family}500` : family // e.g., "blue500" or "white"
	const accentColorVar = hasAccent ? `${family}${accentShade}` : mainColorVar // e.g., "blue200"

	// Generate the CSS class
	themedClasses.push(
		`.Themed--${className} {
	--neo-theme-color: var(--neo-color-${mainColorVar});
	--neo-theme-colorText: var(--neo-color-${textColor});
	--neo-theme-colorAccent: var(--neo-color-${accentColorVar});
}`,
	)
})

// Write CSS variables and themed classes
writeFileSync(
	'./src/assets/styles/colors.css',
	`/**
 * --------------------------------------------------------------------
 * THIS FILE IS AUTO-GENERATED — DO NOT EDIT IT DIRECTLY!
 *
 * This file was generated by the generate-colors script.
 * Any manual changes will be overwritten.
 *
 * To update this file, run the appropriate generation script.
 * --------------------------------------------------------------------
 */

/* Color CSS Variables */
:root {
${cssVars}
}

/* Themed Color Classes */
/* Each color family has ONE class that automatically uses shade 500 and 200 */
/* Usage in components: class="Themed--blue" */
/* Variables provided: */
/*   --neo-theme-color: Main color (automatically shade 500) */
/*   --neo-theme-colorText: Accessible text color (black/white based on WCAG) */
/*   --neo-theme-colorAccent: Lighter accent color (automatically shade 200) */
${themedClasses.join('\n\n')}
`,
)

console.log('✅ colors.css generated')

runScript('npx prettier --write src/assets/styles/colors.css')

/**
 * Generate MD documentation
 */

const mdRowsArr: string[] = []

Object.entries(colorsRaw).forEach(([colorName, shades]) => {
	if (typeof shades === 'object') {
		Object.entries(shades as object)
			.filter(([shade]) => !Number.isNaN(Number(shade)))
			.forEach(([shade]) => {
				mdRowsArr.push(`| ${colorName} | ${shade} | \`--neo-color-${colorName}${shade}\` |`)
			})
	} else if (typeof shades === 'string') {
		mdRowsArr.push(`| ${colorName} | - | \`--neo-color-${colorName.replace('-', '')}\` |`)
	}
})

const mdHeader = `# Material Colors

> Auto-generated documentation of available CSS variables for colors.

| Color | Shade | CSS Variable |
|-------|-------|--------------|
`

const mdContent = `${mdHeader}${mdRowsArr.join('\n')}\n`

const mdFilePath = join(process.cwd(), 'docs/colors.md')
mkdirSync(dirname(mdFilePath), { recursive: true })
writeFileSync(mdFilePath, mdContent)
console.log('✅ Colors.md generated')

/**
 * Generate MDX file out of MD content
 */

const lines = mdContent.split('\n').filter((line) => line.trim().startsWith('|')) // skip header & separator
const rows = lines.slice(2) // skip table header + --- separator

type ColorName = (typeof colorNames)[number]

const dataByColorName: Record<ColorName | 'special', string[]> = Object.fromEntries(
	[...colorNames, 'special'].map((c) => [c, []]),
) as Record<ColorName, string[]>

// Build MDX table rows
rows.forEach((line) => {
	const data = line
		.split('|')
		.map((c) => c.trim())
		.filter((value) => value)

	let name = data[0]
	const value = data[2]

	if (specialColors.includes(name)) {
		name = 'special'
	}

	dataByColorName[name].push(`
			<tr>
				<td>${value}</td>
				<td>
					<div style={{
						display: 'flex',
						justifyContent: 'center',
						alignItems: 'center',

						inlineSize: '4rem',
						blockSize: '4rem',
						margin: 'auto',

						backgroundColor: \`var(${value.replace(/`/g, '')})\`,
						border: '1px solid #ccc'
					}}/>
				</td>
			</tr>
		`)
})

const tables = Object.entries(dataByColorName)
	.filter(([colorName, tableData]) => tableData.length && !specialColors.includes(colorName))
	.map(
		([color, tableData]) => `
<div style={{inlineSize: '100%'}}>
	<h2>${toPascalCase(color)}</h2>
	<table style={{inlineSize: '100%'}}>
		<thead>
			<tr>
				<th>Name</th>
				<th>Preview</th>
			</tr>
		</thead>
		<tbody>
			${tableData.join('')}
		</tbody>
	</table>
</div>
`,
	)

const mdxContent = `
import { Meta, Title, Subtitle } from '@storybook/blocks'

<Meta title="Foundation/Colors" />

<Title>Colors</Title>

{/**
 * --------------------------------------------------------------------
 * THIS FILE IS AUTO-GENERATED — DO NOT EDIT IT DIRECTLY!
 *
 * This file was generated by the generate-colors script.
 * Any manual changes will be overwritten.
 *
 * To update this file, run the appropriate generation script.
 * The script is automatically triggered by the pre-flight script
 * --------------------------------------------------------------------
 */}

<div style={{display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))'}}>
	${tables.join('').replace(/\<\/table\>\n,/g, '<\/table\>')}
</div>
`

mkdirSync('./src/components/00-foundations', { recursive: true })
writeFileSync(`./src/components/00-foundations/colors.mdx`, mdxContent)
console.log(`✅ Storybook MDX generated`)

// Update cache after successful generation
updateCache(SCRIPT_NAME, SOURCE_FILES)
