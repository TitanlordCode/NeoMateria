import colorsRaw from 'material-colors'
import { mkdirSync, writeFileSync } from 'node:fs'
import { runScript } from './utils/script-helper'
import { toShortHex } from './utils/css-helper'
import { dirname, join } from 'node:path'
import { toPascalCase } from '../src/utils/stringManipulation'
import { isAccessible } from '../src/utils/wcag'
import { shouldSkipGeneration, updateCache } from './utils/cache-helper'

const SCRIPT_NAME = 'generate-colors'
const SOURCE_FILES = ['scripts/generate-colors.ts', 'node_modules/material-colors/dist/colors.json']
const OUTPUT_FILES = [
	'src/assets/typescript/colors.ts',
	'src/assets/styles/colors.css',
	'src/assets/styles/mixins/colors.css',
	'docs/colors.md',
	'src/components/00-foundations/colors.mdx',
]

// Check if we can skip generation
if (shouldSkipGeneration(SCRIPT_NAME, SOURCE_FILES, OUTPUT_FILES)) {
	process.exit(0)
}

const specialColors: ColorName[] = ['white', 'black']

/**
 * Generate TS file
 */

const flatColors: Record<string, string> = {}

Object.entries(colorsRaw).forEach(([colorName, shades]) => {
	if (typeof shades === 'object') {
		Object.entries(shades as object).forEach(([shade, value]) => {
			// Only use numeric shades, skip non-numeric (like "A100") if you want or keep all keys
			if (!Number.isNaN(Number(shade))) {
				const key = `${colorName}-${shade}`
				flatColors[key] = value as string
			}
		})
	} else if (typeof shades === 'string') {
		flatColors[colorName] = shades
	}
})

const colorNames: string[] = Object.keys(flatColors)
	.map((color) => color.split('-')[0])
	.reduce((result: string[], current) => {
		if (!result.includes(current)) {
			result.push(current)
		}
		return result
	}, [])

// Generate color family names (without shade numbers) - excluding special colors
const colorFamilies = colorNames.filter((name) => !specialColors.includes(name))

const tsContent = `/**
 * --------------------------------------------------------------------
 * THIS FILE IS AUTO-GENERATED — DO NOT EDIT IT DIRECTLY!
 *
 * This file was generated by the generate-colors script.
 * Any manual changes will be overwritten.
 * --------------------------------------------------------------------
 */

/**
 * array for all possible colors names (including special colors)
*/
export const colorNames = \n${JSON.stringify(colorNames, null, 2)} as const

/**
 * array for color families (without shade numbers)
 * Users specify these, and CSS handles the specific shade (500 by default)
*/
export const colors = \n${JSON.stringify(colorFamilies, null, 2)} as const

/**
 * type that define all colors available for components
 * Only color families are exposed (e.g., "blue", "green", not "blue500")
*/
export type Color = typeof colors[number]

/**
 * object of all possible color values with shades
 * Internal use only - for CSS generation
*/
export const colorsFlat = ${JSON.stringify(flatColors, null, 2)}
`

writeFileSync('src/assets/typescript/colors.ts', tsContent)

console.log('✅ colors.ts generated')

runScript('npx prettier --write src/assets/typescript/colors.ts')

/**
 * Generate CSS file
 */

// CSS colors
const cssVarsArr: string[] = []

Object.entries(flatColors).forEach(([colorName, value]) => {
	cssVarsArr.push(`\t--neo-color-${colorName.replace('-', '')}: ${toShortHex(value)};`)
})

const cssVars = cssVarsArr.join('\n')

// Generate themed CSS mixins for all color shades
const themedMixins: string[] = []

Object.entries(flatColors).forEach(([colorName, value]) => {
	const bg = toShortHex(value)
	let textColor = 'white'

	if (isAccessible(bg, '#000000')) {
		textColor = 'black'
	} else if (isAccessible(bg, '#ffffff')) {
		textColor = 'white'
	}

	const mixinName = colorName.replace('-', '')
	const [family, shade] = colorName.split('-')
	const shadeNum = parseInt(shade || '0')

	// Determine accent shade (lighter version, typically 200)
	let accentShade = '200'
	if (shadeNum <= 200) {
		accentShade = '100'
	} else if (shadeNum <= 400) {
		accentShade = '200'
	} else {
		accentShade = '300'
	}

	// Determine onDark shade
	let onDarkShade = '200'
	if (shadeNum <= 200) {
		onDarkShade = '100'
	} else if (shadeNum <= 400) {
		onDarkShade = '200'
	} else {
		onDarkShade = '300'
	}

	const accentShadeKey = `${family}-${accentShade}`
	const accentColor = flatColors[accentShadeKey]

	const lightShadeKey = `${family}-${onDarkShade}`
	const lightColor = flatColors[lightShadeKey]

	// Get accent text color
	let accentTextColor = 'white'
	if (accentColor) {
		const accentBg = toShortHex(accentColor)
		if (isAccessible(accentBg, '#000000')) {
			accentTextColor = 'black'
		} else if (isAccessible(accentBg, '#ffffff')) {
			accentTextColor = 'white'
		}
	}

	// Generate the basic mixin
	themedMixins.push(
		`@define-mixin Themed--${mixinName} {
	--neo-theme-color: var(--neo-color-${mixinName});
	--neo-theme-colorText: var(--neo-color-${textColor});
	--neo-theme-colorAccent: var(--neo-color-${family}${accentShade});
}`,
	)
})

// Write CSS variables
writeFileSync(
	'./src/assets/styles/colors.css',
	`/**
 * --------------------------------------------------------------------
 * THIS FILE IS AUTO-GENERATED — DO NOT EDIT IT DIRECTLY!
 *
 * This file was generated by the generate-colors script.
 * Any manual changes will be overwritten.
 *
 * To update this file, run the appropriate generation script.
 * --------------------------------------------------------------------
 */

:root {
${cssVars}
}
`,
)

console.log('✅ colors.css generated')

// Write color mixins to mixins directory
mkdirSync('./src/assets/styles/mixins', { recursive: true })
writeFileSync(
	'./src/assets/styles/mixins/colors.css',
	`/**
 * --------------------------------------------------------------------
 * THIS FILE IS AUTO-GENERATED — DO NOT EDIT IT DIRECTLY!
 *
 * This file was generated by the generate-colors script.
 * Any manual changes will be overwritten.
 *
 * To update this file, run the appropriate generation script.
 * --------------------------------------------------------------------
 */

/* Themed color mixins */
/* Components use these mixins in their themed CSS files to get color variables */
/* Usage in component CSS: @mixin Themed--blue500; */
/* Variables provided: */
/*   --neo-theme-color: Main color (e.g., shade 500) */
/*   --neo-theme-colorText: Accessible text color (black/white based on WCAG) */
/*   --neo-theme-colorAccent: Lighter accent color (e.g., shade 200) */
/*  */
/* For dark mode support, manually use the existing onDark mixin from theming.css: */
/* Example: .MyComponent--blue { @mixin Themed--blue500; @mixin onDark { ... } } */
${themedMixins.join('\n\n')}
`,
)

console.log('✅ colors mixin file generated')

runScript('npx prettier --write src/assets/styles/colors.css')
runScript('npx prettier --write src/assets/styles/mixins/colors.css')

/**
 * Generate MD documentation
 */

const mdRowsArr: string[] = []

Object.entries(colorsRaw).forEach(([colorName, shades]) => {
	if (typeof shades === 'object') {
		Object.entries(shades as object)
			.filter(([shade]) => !Number.isNaN(Number(shade)))
			.forEach(([shade]) => {
				mdRowsArr.push(`| ${colorName} | ${shade} | \`--neo-color-${colorName}${shade}\` |`)
			})
	} else if (typeof shades === 'string') {
		mdRowsArr.push(`| ${colorName} | - | \`--neo-color-${colorName.replace('-', '')}\` |`)
	}
})

const mdHeader = `# Material Colors

> Auto-generated documentation of available CSS variables for colors.

| Color | Shade | CSS Variable |
|-------|-------|--------------|
`

const mdContent = `${mdHeader}${mdRowsArr.join('\n')}\n`

const mdFilePath = join(process.cwd(), 'docs/colors.md')
mkdirSync(dirname(mdFilePath), { recursive: true })
writeFileSync(mdFilePath, mdContent)
console.log('✅ Colors.md generated')

/**
 * Generate MDX file out of MD content
 */

const lines = mdContent.split('\n').filter((line) => line.trim().startsWith('|')) // skip header & separator
const rows = lines.slice(2) // skip table header + --- separator

type ColorName = (typeof colorNames)[number]

const dataByColorName: Record<ColorName | 'special', string[]> = Object.fromEntries(
	[...colorNames, 'special'].map((c) => [c, []]),
) as Record<ColorName, string[]>

// Build MDX table rows
rows.forEach((line) => {
	const data = line
		.split('|')
		.map((c) => c.trim())
		.filter((value) => value)

	let name = data[0]
	const value = data[2]

	if (specialColors.includes(name)) {
		name = 'special'
	}

	dataByColorName[name].push(`
			<tr>
				<td>${value}</td>
				<td>
					<div style={{
						display: 'flex',
						justifyContent: 'center',
						alignItems: 'center',

						inlineSize: '4rem',
						blockSize: '4rem',
						margin: 'auto',

						backgroundColor: \`var(${value.replace(/`/g, '')})\`,
						border: '1px solid #ccc'
					}}/>
				</td>
			</tr>
		`)
})

const tables = Object.entries(dataByColorName)
	.filter(([colorName, tableData]) => tableData.length && !specialColors.includes(colorName))
	.map(
		([color, tableData]) => `
<div style={{inlineSize: '100%'}}>
	<h2>${toPascalCase(color)}</h2>
	<table style={{inlineSize: '100%'}}>
		<thead>
			<tr>
				<th>Name</th>
				<th>Preview</th>
			</tr>
		</thead>
		<tbody>
			${tableData.join('')}
		</tbody>
	</table>
</div>
`,
	)

const mdxContent = `
import { Meta, Title, Subtitle } from '@storybook/blocks'

<Meta title="Foundation/Colors" />

<Title>Colors</Title>

{/**
 * --------------------------------------------------------------------
 * THIS FILE IS AUTO-GENERATED — DO NOT EDIT IT DIRECTLY!
 *
 * This file was generated by the generate-colors script.
 * Any manual changes will be overwritten.
 *
 * To update this file, run the appropriate generation script.
 * The script is automatically triggered by the pre-flight script
 * --------------------------------------------------------------------
 */}

<div style={{display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))'}}>
	${tables.join('').replace(/\<\/table\>\n,/g, '<\/table\>')}
</div>
`

mkdirSync('./src/components/00-foundations', { recursive: true })
writeFileSync(`./src/components/00-foundations/colors.mdx`, mdxContent)
console.log(`✅ Storybook MDX generated`)

// Update cache after successful generation
updateCache(SCRIPT_NAME, SOURCE_FILES)
